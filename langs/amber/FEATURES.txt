
AMBER PROGRAMMING LANGUAGE FEATURES LIST

Features already implemented are marked with a -
Features awaiting implementation are marked with a +
Debated features which may not implemented as stated or even implmented at all are marked with a *

=== GENERAL SYNTAX ===

- C-like flexible lexer
- Abstract Syntax Tree generator that subdivides all statements into nested expressions and blocks and respects stuff like operator precedence
- Comments
+ Preprocessor for stuff like #alias
+ Automatic and manual memory managers, with their own special syntax and all

=== ATTRIBUTES ===

+ freeze
+ debug
+ auto, manual
+ implicit, explicit
* cold, mild, hot

=== STATEMENTS ===

- if
- else
* elif (else if)
- loop
* iterate (used to use this, but even I'm doubting its use, so I don't this this will ever happen)
- while
- continue
- break
* break(n) (breaking multiple loops with a single statement, may make the loops compiler too complex)
* switc... haha no I'm just kidding, I will *try* to never touch one of those ugly bastards ever again
* do ... while (seriously, what's the point? I'll add it if people want it, but I don't see the point)
* for (I'm not sure what the best way of implementing these should be. I honestly can't find any other reason to have this in Amber apart from if it's some kind of for ... in ... loop)
- func (functions)
+ class (name spaces)
- return
* lab and goto
- declarations

=== OPERATIONS ===

- Integer addition (+), subtraction (-), multiplication (*), division (/)
- Integer modulo (%)
- Integer comparison conditions: equal to (==), not equal to (!=) greater than (>), less than (<), greater or equal (>=), less or equal (<=)
- Logical and (&&, and), or (||, or)
- Logical not (!, not)
- Logical normalization (|, nrm)
- Logical xor (^^, xor)
- Unary minus (-)
- Unary plus (+)
- Pointer reference (&), dereference (?) and byte dereference (*)
+ Bitwise and (&), or (|), xor (^), left shift (<<), right shift (>>)
- Two's complement (~)
* Integer increment (++) and decrement (--)
- String concatenation (++)
* String formatting (%%)
- String equivalency (===) and non-equivalency (!==) conditions
* String multiplication (**)
- Assignment (=)
+ Self-assignment with all currently implemented operations (<operator>=)

=== TYPES ===

- var
- byte
+ flt
* bool
+ [] (lists)
+ class (data structures)

=== LITERALS ===

- String literals
- Decimal interger literals
+ Floating point literals
+ Array literals
- Hexadecimal integer literals
+ Binary integer literals
+ Single or multi-char literals

=== BUILTINS ===

+ Casts to different types (<type name>(<thing to be cast>), such as int("9") == 9)
- str(number, base) function to turn any number into a string representation with any base
